/*
 * Copyright (c) 2021 Soar Qin<soarchin@gmail.com>
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

#include "d2txt.h"
#include "jsonlng.h"

#include "CascLib.h"
#include "ini.h"

#include <fstream>

char *loadFileToMem(HANDLE storage, const char *filename, size_t &size) {
    HANDLE file;
    if (!CascOpenFile(storage, filename, CASC_LOCALE_ALL, CASC_OPEN_BY_NAME, &file)) {
        CascCloseStorage(storage);
        return nullptr;
    }
    size = CascGetFileSize(file, nullptr);
    char *data = new char[size];
    CascReadFile(file, data, size, nullptr);
    CascCloseFile(file);
    return data;
}

bool loadTxt(D2TXT &txt, HANDLE storage, const char *filename) {
    size_t size;
    auto *data = loadFileToMem(storage, filename, size);
    if (!data) {
        return false;
    }
    txt.load(data, size);
    delete[] data;
    return true;
}

bool loadJsonLng(JsonLng &jlng, HANDLE storage, const char *filename) {
    size_t size;
    auto *data = loadFileToMem(storage, filename, size);
    if (!data) {
        return false;
    }
    jlng.load(data, size);
    delete[] data;
    return true;
}

int main(int argc, char *argv[]) {
    struct UserParseData {
        /* -1-not used  0-guides  1-useful_names  2-useful_objects  3-name_replace */
        int section = -1;
        std::map<std::string, std::string> usefulNames;
        std::map<int, std::string> usefulObjects, nameReplace;
    } parseData;
    ini_parse("gendata.ini", [](void* user, const char* section, const char* name, const char* value)->int {
        auto *pd = (UserParseData*)user;
        if (!name) {
            if (!strcmp(section, "guides")) {
                pd->section = 0;
            } else if (!strcmp(section, "useful_names")) {
                pd->section = 1;
            } else if (!strcmp(section, "useful_objects")) {
                pd->section = 2;
            } else if (!strcmp(section, "name_replace")) {
                pd->section = 3;
            } else {
                pd->section = -1;
            }
            return 1;
        }
        switch (pd->section) {
        case 0:
            break;
        case 1: {
            pd->usefulNames[name] = value;
            break;
        }
        case 2: {
            pd->usefulObjects[strtol(name, nullptr, 0)] = value;
            break;
        }
        case 3: {
            pd->nameReplace[strtol(name, nullptr, 0)] = value;
            break;
        }
        default:
            break;
        }
        return 1;
    }, &parseData);

    HANDLE storage;
    char path[512];
    snprintf(path, 512, "%s\\Data", argv[1]);
    if (!CascOpenStorage(path, CASC_LOCALE_ALL, &storage)) {
        return -1;
    }

    JsonLng jlng;
    loadJsonLng(jlng, storage, "data:data/local/lng/strings/item-names.json");
    loadJsonLng(jlng, storage, "data:data/local/lng/strings/levels.json");
    loadJsonLng(jlng, storage, "data:data/local/lng/strings/npcs.json");
    loadJsonLng(jlng, storage, "data:data/local/lng/strings/objects.json");

    D2TXT levelTxt, objTxt;
    loadTxt(levelTxt, storage, "data:data/global/excel/levels.txt");
    loadTxt(objTxt, storage, "data:data/global/excel/objects.txt");
    CascCloseStorage(storage);

    std::map<std::string, std::array<std::string, JsonLng::LNG_MAX>> strings;

    std::ofstream ofs("D2RMH_data.ini");

    ofs << ";DO NOT EDIT THIS FILE!!!" << std::endl << std::endl;
    ofs << '[' << "levels" << ']' << std::endl;
    auto idx0 = levelTxt.colIndexByName("Id");
    auto idx1 = levelTxt.colIndexByName("LevelName");
    auto rows = levelTxt.rows();
    for (size_t i = 0; i < rows; ++i) {
        auto id = levelTxt.value(i, idx0).second;
        const auto &key = levelTxt.value(i, idx1).first;
        const auto *arr = jlng.get(key);
        if (arr) {
            strings[key] = *arr;
            ofs << id << '=' << key << std::endl;
        }
    }

    ofs << std::endl << '[' << "objects" << ']' << std::endl;
    idx0 = objTxt.colIndexByName("*ID");
    idx1 = objTxt.colIndexByName("Name");
    rows = objTxt.rows();
    for (size_t i = 0; i < rows; ++i) {
        auto id = objTxt.value(i, idx0).second;
        auto key = objTxt.value(i, idx1).first;
        auto kite = parseData.usefulNames.find(key);
        std::string typeStr;
        if (kite == parseData.usefulNames.end()) {
            auto ite = parseData.usefulObjects.find(id);
            if (ite == parseData.usefulObjects.end()) { continue; }
            typeStr = ite->second;
            auto rite = parseData.nameReplace.find(id);
            if (rite != parseData.nameReplace.end()) {
                key = rite->second;
            }
        } else {
            typeStr = kite->second;
        }
        const auto *arr = jlng.get(key);
        if (arr) {
            strings[key] = *arr;
            ofs << id << '=' << typeStr << '|' << key << std::endl;
        }
    }

    ofs << std::endl << '[' << "strings" << ']' << std::endl;
    for (auto &p: strings) {
        for (size_t i = 0; i < p.second.size(); ++i) {
            ofs << p.first << '[' << i << "]=" << p.second[i] << std::endl;
        }
    }
    ofs.close();
    return 0;
}

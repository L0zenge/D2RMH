/*
 * Copyright (c) 2021 Soar Qin<soarchin@gmail.com>
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 */

#include "d2txt.h"
#include "jsonlng.h"

#include "CascLib.h"
#include "ini.h"

#include <fstream>
#include <map>
#include <set>

char *loadFileToMem(HANDLE storage, const char *filename, size_t &size) {
    HANDLE file;
    if (!CascOpenFile(storage, filename, CASC_LOCALE_ALL, CASC_OPEN_BY_NAME, &file)) {
        CascCloseStorage(storage);
        return nullptr;
    }
    size = CascGetFileSize(file, nullptr);
    char *data = new char[size];
    CascReadFile(file, data, size, nullptr);
    CascCloseFile(file);
    return data;
}

bool loadTxt(D2TXT &txt, HANDLE storage, const char *filename) {
    size_t size;
    auto *data = loadFileToMem(storage, filename, size);
    if (!data) {
        return false;
    }
    txt.load(data, size);
    delete[] data;
    return true;
}

bool loadJsonLng(JsonLng &jlng, HANDLE storage, const char *filename) {
    size_t size;
    auto *data = loadFileToMem(storage, filename, size);
    if (!data) {
        return false;
    }
    jlng.load(data, size);
    delete[] data;
    return true;
}

int main(int argc, char *argv[]) {
    struct UserParseData {
        /* -1-not used  0-guides  1-useful_names  2-useful_objects  3-name_replace */
        int section = -1;
        std::map<std::string, std::string> usefulNames;
        std::map<int, std::string> usefulObjects, usefulNpcs, nameReplace;
        std::map<std::string, std::set<std::string>> guides;
    } parseData;
    ini_parse("gendata.ini", [](void* user, const char* section, const char* name, const char* value)->int {
        auto *pd = (UserParseData*)user;
        if (!name) {
            if (!strcmp(section, "guides")) {
                pd->section = 0;
            } else if (!strcmp(section, "useful_names")) {
                pd->section = 1;
            } else if (!strcmp(section, "useful_objects")) {
                pd->section = 2;
            } else if (!strcmp(section, "useful_npcs")) {
                pd->section = 3;
            } else if (!strcmp(section, "name_replace")) {
                pd->section = 4;
            } else {
                pd->section = -1;
            }
            return 1;
        }
        switch (pd->section) {
        case 0: {
            if (strtoul(value, nullptr, 0) == 0) {
                break;
            }
            if (strncmp(name, "guide[", 6) != 0) {
                break;
            }
            const char *start = name + 6;
            const char *token = strchr(name, ']');
            if (token == nullptr) { break; }
            const char *start2 = strchr(token + 1, '[');
            if (start2 == nullptr) { break; }
            ++start2;
            const char *token2 = strchr(start2, ']');
            if (token2 == nullptr) { break; }
            pd->guides[std::string(start, token)].insert(std::string(start2, token2));
        }
        case 1: {
            pd->usefulNames[name] = value;
            break;
        }
        case 2: {
            pd->usefulObjects[strtol(name, nullptr, 0)] = value;
            break;
        }
        case 3: {
            pd->usefulNpcs[strtol(name, nullptr, 0)] = value;
            break;
        }
        case 4: {
            pd->nameReplace[strtol(name, nullptr, 0)] = value;
            break;
        }
        default:
            break;
        }
        return 1;
    }, &parseData);

    HANDLE storage;
    char path[512];
    snprintf(path, 512, "%s\\Data", argv[1]);
    if (!CascOpenStorage(path, CASC_LOCALE_ALL, &storage)) {
        return -1;
    }

    JsonLng jlng;
    loadJsonLng(jlng, storage, "data:data/local/lng/strings/item-names.json");
    loadJsonLng(jlng, storage, "data:data/local/lng/strings/levels.json");
    loadJsonLng(jlng, storage, "data:data/local/lng/strings/monsters.json");
    loadJsonLng(jlng, storage, "data:data/local/lng/strings/npcs.json");
    loadJsonLng(jlng, storage, "data:data/local/lng/strings/objects.json");

    D2TXT levelTxt, objTxt;
    loadTxt(levelTxt, storage, "data:data/global/excel/levels.txt");
    loadTxt(objTxt, storage, "data:data/global/excel/objects.txt");
    CascCloseStorage(storage);

    std::map<std::string, std::array<std::string, JsonLng::LNG_MAX>> strings;
    std::map<std::string, int> levelIdByName;

    std::ofstream ofs("D2RMH_data.ini");

    ofs << ";!!!THIS FILE IS GENERATED BY TOOL, DO NOT EDIT!!!" << std::endl << std::endl;
    ofs << '[' << "levels" << ']' << std::endl;
    auto idx0 = levelTxt.colIndexByName("Id");
    auto idx1 = levelTxt.colIndexByName("LevelName");
    auto rows = levelTxt.rows();
    for (size_t i = 0; i < rows; ++i) {
        auto id = levelTxt.value(i, idx0).second;
        const auto &key = levelTxt.value(i, idx1).first;
        const auto *arr = jlng.get(key);
        if (arr) {
            strings[key] = *arr;
            ofs << id << '=' << key << std::endl;
            levelIdByName[(*arr)[0]] = id;
        }
    }

    ofs << std::endl << '[' << "objects" << ']' << std::endl;
    idx0 = objTxt.colIndexByName("*ID");
    idx1 = objTxt.colIndexByName("Name");
    rows = objTxt.rows();
    for (size_t i = 0; i < rows; ++i) {
        auto id = objTxt.value(i, idx0).second;
        auto key = objTxt.value(i, idx1).first;
        auto kite = parseData.usefulNames.find(key);
        std::string typeStr;
        if (kite == parseData.usefulNames.end()) {
            auto ite = parseData.usefulObjects.find(id);
            if (ite == parseData.usefulObjects.end()) { continue; }
            typeStr = ite->second;
            auto rite = parseData.nameReplace.find(id);
            if (rite != parseData.nameReplace.end()) {
                key = rite->second;
            }
        } else {
            typeStr = kite->second;
        }
        const auto *arr = jlng.get(key);
        if (arr) {
            strings[key] = *arr;
            ofs << id << '=' << typeStr << '|' << key << std::endl;
        }
    }

    ofs << std::endl << '[' << "npcs" << ']' << std::endl;
    for (auto &p: parseData.usefulNpcs) {
        const auto *arr = jlng.get(p.second);
        if (arr) {
            strings[p.second] = *arr;
            ofs << p.first << '=' << p.second << std::endl;
        }
    }

    ofs << std::endl << '[' << "strings" << ']' << std::endl;
    for (auto &p: strings) {
        for (size_t i = 0; i < p.second.size(); ++i) {
            ofs << p.first << '[' << i << "]=" << p.second[i] << std::endl;
        }
    }

    ofs << std::endl << '[' << "guides" << ']' << std::endl;
    for (auto &p: parseData.guides) {
        int id;
        if (p.first[0] >= '0' && p.first[0] <= '9') {
            id = strtol(p.first.c_str(), nullptr, 0);
        } else {
            auto ite = levelIdByName.find(p.first);
            if (ite == levelIdByName.end()) {
                std::cerr << "Not found: " << p.first << std::endl;
                continue;
            }
            id = ite->second;
        }
        for (auto &s: p.second) {
            if (s.empty()) { continue; }
            if (s[0] == '+' || s[0] == '-' || (s[0] >= '0' && s[0] <= '9')) {
                ofs << id << '=' << s << std::endl;
                continue;
            }
            auto ite2 = levelIdByName.find(s);
            if (ite2 == levelIdByName.end()) {
                std::cerr << "Not found: " << s << std::endl;
                continue;
            }
            ofs << id << '=' << ite2->second << std::endl;
        }
    }
    ofs.close();
    return 0;
}
